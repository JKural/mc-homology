<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mc-homology: algebra Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mc-homology
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacealgebra.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">algebra Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:SkipCorrectnessCheckT" id="r_SkipCorrectnessCheckT"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structalgebra_1_1SkipCorrectnessCheckT.html">SkipCorrectnessCheckT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to mark an overload of a function, that doesn't perform optional correctness checks. Such overloads should only be used after manually ensuring, that other parameters guarantee correct output.  <a href="structalgebra_1_1SkipCorrectnessCheckT.html#details">More...</a><br /></td></tr>
<tr class="memitem:ChainComplex" id="r_ChainComplex"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classalgebra_1_1ChainComplex.html">ChainComplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a chain complex with coefficients <span class="tt">T</span>.  <a href="classalgebra_1_1ChainComplex.html#details">More...</a><br /></td></tr>
<tr class="memitem:Homology" id="r_Homology"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structalgebra_1_1Homology.html">Homology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structalgebra_1_1Homology.html" title="Homology of a chain complex.">Homology</a> of a chain complex.  <a href="structalgebra_1_1Homology.html#details">More...</a><br /></td></tr>
<tr class="memitem:Integer" id="r_Integer"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of Integers.  <a href="classalgebra_1_1Integer.html#details">More...</a><br /></td></tr>
<tr class="memitem:Matrix" id="r_Matrix"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classalgebra_1_1Matrix.html" title="A Matrix class.">Matrix</a> class.  <a href="classalgebra_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="memitem:RowEchelonFormResult" id="r_RowEchelonFormResult"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structalgebra_1_1RowEchelonFormResult.html">RowEchelonFormResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result struct for the row echelon algorithm.  <a href="structalgebra_1_1RowEchelonFormResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:SmithFormResult" id="r_SmithFormResult"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structalgebra_1_1SmithFormResult.html">SmithFormResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result struct for the smith algorithm.  <a href="structalgebra_1_1SmithFormResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:ZModP" id="r_ZModP"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="conceptalgebra_1_1Field.html" title="A field concept.">Field</a> of integers modulo P.  <a href="classalgebra_1_1ZModP.html#details">More...</a><br /></td></tr>
<tr class="memitem:DivResult" id="r_DivResult"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structalgebra_1_1DivResult.html">DivResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result struct for the division operation.  <a href="structalgebra_1_1DivResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExtendedGCDResult" id="r_ExtendedGCDResult"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structalgebra_1_1ExtendedGCDResult.html">ExtendedGCDResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result struct for the extended gcd algorithm.  <a href="structalgebra_1_1ExtendedGCDResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:ZModP_3C_202_20_3E" id="r_ZModP_3C_202_20_3E"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classalgebra_1_1ZModP_3_012_01_4.html">ZModP&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for P == 2.  <a href="classalgebra_1_1ZModP_3_012_01_4.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:Commutative" id="r_Commutative"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptalgebra_1_1Commutative.html">Commutative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abelian structure concept. <br /></td></tr>
<tr class="memitem:Group" id="r_Group"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptalgebra_1_1Group.html">Group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A group concept. <br /></td></tr>
<tr class="memitem:AdditiveGroup" id="r_AdditiveGroup"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptalgebra_1_1AdditiveGroup.html">AdditiveGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An additive group concept. <br /></td></tr>
<tr class="memitem:Ring" id="r_Ring"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptalgebra_1_1Ring.html">Ring</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ring concept. <br /></td></tr>
<tr class="memitem:CommutativeRing" id="r_CommutativeRing"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptalgebra_1_1CommutativeRing.html">CommutativeRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An commutative ring concept. <br /></td></tr>
<tr class="memitem:EuclideanDomain" id="r_EuclideanDomain"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptalgebra_1_1EuclideanDomain.html">EuclideanDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An euclidean domain concept. <br /></td></tr>
<tr class="memitem:Field" id="r_Field"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptalgebra_1_1Field.html">Field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A field concept. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1fa07827605fa9734220db771470424d" id="r_a1fa07827605fa9734220db771470424d"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a1fa07827605fa9734220db771470424d">Z2</a> = <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt;2&gt;</td></tr>
<tr class="memdesc:a1fa07827605fa9734220db771470424d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classalgebra_1_1ZModP_3_012_01_4.html" title="Template specialization for P == 2.">ZModP&lt;2&gt;</a>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3b6f25acf54da436f6f0e4e65d317158" id="r_a3b6f25acf54da436f6f0e4e65d317158"><td class="memTemplParams" colspan="2">template&lt;EuclideanDomain T&gt; </td></tr>
<tr class="memitem:a3b6f25acf54da436f6f0e4e65d317158 template"><td class="memItemLeft"><a class="el" href="structalgebra_1_1Homology.html">Homology</a>&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a3b6f25acf54da436f6f0e4e65d317158">homology</a> (<a class="el" href="classalgebra_1_1ChainComplex.html">ChainComplex</a>&lt; T &gt; const &amp;chain_complex)</td></tr>
<tr class="memdesc:a3b6f25acf54da436f6f0e4e65d317158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes homology of a chain complex with coefficients from an euclidean domain.  <br /></td></tr>
<tr class="memitem:a3b6f25acf54da436f6f0e4e65d317158" id="r_a3b6f25acf54da436f6f0e4e65d317158"><td class="memTemplParams" colspan="2">template&lt;Field T&gt; </td></tr>
<tr class="memitem:a3b6f25acf54da436f6f0e4e65d317158 template"><td class="memItemLeft"><a class="el" href="structalgebra_1_1Homology.html">Homology</a>&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a3b6f25acf54da436f6f0e4e65d317158">homology</a> (<a class="el" href="classalgebra_1_1ChainComplex.html">ChainComplex</a>&lt; T &gt; const &amp;chain_complex)</td></tr>
<tr class="memdesc:a3b6f25acf54da436f6f0e4e65d317158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes homology of a chain complex with coefficients from a field.  <br /></td></tr>
<tr class="memitem:a1289f308542d523475a6610977fb0f09" id="r_a1289f308542d523475a6610977fb0f09"><td class="memTemplParams" colspan="2">template&lt;std::ranges::sized_range R&gt; </td></tr>
<tr class="memitem:a1289f308542d523475a6610977fb0f09 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a1289f308542d523475a6610977fb0f09">ChainComplex</a> (<a class="el" href="structalgebra_1_1SkipCorrectnessCheckT.html">SkipCorrectnessCheckT</a>, R &amp;&amp;) -&gt; ChainComplex&lt; typename std::ranges::range_value_t&lt; R &gt;::value_type &gt;</td></tr>
<tr class="memdesc:a1289f308542d523475a6610977fb0f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for the <a class="el" href="classalgebra_1_1ChainComplex.html" title="Class representing a chain complex with coefficients T.">ChainComplex</a>.  <br /></td></tr>
<tr class="memitem:ae5a6158e073a7727781c1aecc8ee5afb" id="r_ae5a6158e073a7727781c1aecc8ee5afb"><td class="memTemplParams" colspan="2">template&lt;std::ranges::sized_range R&gt; </td></tr>
<tr class="memitem:ae5a6158e073a7727781c1aecc8ee5afb template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ae5a6158e073a7727781c1aecc8ee5afb">ChainComplex</a> (R &amp;&amp;) -&gt; ChainComplex&lt; typename std::ranges::range_value_t&lt; R &gt;::value_type &gt;</td></tr>
<tr class="memdesc:ae5a6158e073a7727781c1aecc8ee5afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for the <a class="el" href="classalgebra_1_1ChainComplex.html" title="Class representing a chain complex with coefficients T.">ChainComplex</a>.  <br /></td></tr>
<tr class="memitem:ade04e6b8cc549a66f70769f8c44104f8" id="r_ade04e6b8cc549a66f70769f8c44104f8"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1Integer.html">Integer</a>&#160;</td><td class="memItemRight"><a class="el" href="#ade04e6b8cc549a66f70769f8c44104f8">operator+</a> (<a class="el" href="classalgebra_1_1Integer.html">Integer</a> lhs, <a class="el" href="classalgebra_1_1Integer.html">Integer</a> rhs) noexcept</td></tr>
<tr class="memdesc:ade04e6b8cc549a66f70769f8c44104f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two integers.  <br /></td></tr>
<tr class="memitem:acb08f898d9c1b3fd624ef42e41a605a1" id="r_acb08f898d9c1b3fd624ef42e41a605a1"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1Integer.html">Integer</a>&#160;</td><td class="memItemRight"><a class="el" href="#acb08f898d9c1b3fd624ef42e41a605a1">operator-</a> (<a class="el" href="classalgebra_1_1Integer.html">Integer</a> lhs, <a class="el" href="classalgebra_1_1Integer.html">Integer</a> rhs) noexcept</td></tr>
<tr class="memdesc:acb08f898d9c1b3fd624ef42e41a605a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two integers.  <br /></td></tr>
<tr class="memitem:a442462c93fc9e0ebffcc6e517e9e3796" id="r_a442462c93fc9e0ebffcc6e517e9e3796"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1Integer.html">Integer</a>&#160;</td><td class="memItemRight"><a class="el" href="#a442462c93fc9e0ebffcc6e517e9e3796">operator*</a> (<a class="el" href="classalgebra_1_1Integer.html">Integer</a> lhs, <a class="el" href="classalgebra_1_1Integer.html">Integer</a> rhs) noexcept</td></tr>
<tr class="memdesc:a442462c93fc9e0ebffcc6e517e9e3796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two integers.  <br /></td></tr>
<tr class="memitem:a9cc47983d14c3338d843c8fe61f6d7ae" id="r_a9cc47983d14c3338d843c8fe61f6d7ae"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1Integer.html">Integer</a>&#160;</td><td class="memItemRight"><a class="el" href="#a9cc47983d14c3338d843c8fe61f6d7ae">abs</a> (<a class="el" href="classalgebra_1_1Integer.html">Integer</a> k) noexcept</td></tr>
<tr class="memdesc:a9cc47983d14c3338d843c8fe61f6d7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns absolute value.  <br /></td></tr>
<tr class="memitem:a9d5f1816c22b13d7a8a6a9a93aaa0258" id="r_a9d5f1816c22b13d7a8a6a9a93aaa0258"><td class="memItemLeft">constexpr <a class="el" href="structalgebra_1_1DivResult.html">DivResult</a>&lt; <a class="el" href="classalgebra_1_1Integer.html">Integer</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a9d5f1816c22b13d7a8a6a9a93aaa0258">divide</a> (<a class="el" href="classalgebra_1_1Integer.html">Integer</a> a, <a class="el" href="classalgebra_1_1Integer.html">Integer</a> b)</td></tr>
<tr class="memdesc:a9d5f1816c22b13d7a8a6a9a93aaa0258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of integer division for Integers a and b.  <br /></td></tr>
<tr class="memitem:a7557df3e0d51e921d301661b095a8ccf" id="r_a7557df3e0d51e921d301661b095a8ccf"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1Integer.html">Integer</a>&#160;</td><td class="memItemRight"><a class="el" href="#a7557df3e0d51e921d301661b095a8ccf">modulo</a> (<a class="el" href="classalgebra_1_1Integer.html">Integer</a> a, <a class="el" href="classalgebra_1_1Integer.html">Integer</a> n)</td></tr>
<tr class="memdesc:a7557df3e0d51e921d301661b095a8ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the remainder of division of a by n.  <br /></td></tr>
<tr class="memitem:a33030836db242b656162529d27fc5ffd" id="r_a33030836db242b656162529d27fc5ffd"><td class="memItemLeft">std::ostream &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a33030836db242b656162529d27fc5ffd">operator&lt;&lt;</a> (std::ostream &amp;output, <a class="el" href="classalgebra_1_1Integer.html">Integer</a> k)</td></tr>
<tr class="memdesc:a33030836db242b656162529d27fc5ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs an integer to a stream.  <br /></td></tr>
<tr class="memitem:a195973a6e4664deb9f404a54d2c04d1b" id="r_a195973a6e4664deb9f404a54d2c04d1b"><td class="memTemplParams" colspan="2">template&lt;AdditiveGroup T&gt; </td></tr>
<tr class="memitem:a195973a6e4664deb9f404a54d2c04d1b template"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a195973a6e4664deb9f404a54d2c04d1b">operator+</a> (<a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; lhs, <a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a195973a6e4664deb9f404a54d2c04d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two matrices.  <br /></td></tr>
<tr class="memitem:a04836ac6e8513865e36e05ceaa77c356" id="r_a04836ac6e8513865e36e05ceaa77c356"><td class="memTemplParams" colspan="2">template&lt;AdditiveGroup T&gt; </td></tr>
<tr class="memitem:a04836ac6e8513865e36e05ceaa77c356 template"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a04836ac6e8513865e36e05ceaa77c356">operator-</a> (<a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; lhs, <a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a04836ac6e8513865e36e05ceaa77c356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two matrices.  <br /></td></tr>
<tr class="memitem:a730f43d3ab3095a9a724122b2af5926e" id="r_a730f43d3ab3095a9a724122b2af5926e"><td class="memTemplParams" colspan="2">template&lt;Ring T&gt; </td></tr>
<tr class="memitem:a730f43d3ab3095a9a724122b2af5926e template"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a730f43d3ab3095a9a724122b2af5926e">operator*</a> (<a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a730f43d3ab3095a9a724122b2af5926e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two matrices.  <br /></td></tr>
<tr class="memitem:abed0b66c149933f74c933def897afa3c" id="r_abed0b66c149933f74c933def897afa3c"><td class="memTemplParams" colspan="2">template&lt;std::ranges::sized_range R&gt; </td></tr>
<tr class="memitem:abed0b66c149933f74c933def897afa3c template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#abed0b66c149933f74c933def897afa3c">Matrix</a> (R &amp;&amp;, std::size_t, std::size_t) -&gt; Matrix&lt; std::ranges::range_value_t&lt; R &gt; &gt;</td></tr>
<tr class="memdesc:abed0b66c149933f74c933def897afa3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce matrix value type from the submitted range.  <br /></td></tr>
<tr class="memitem:ab537d2f6e9272715838b5eada4cb13ce" id="r_ab537d2f6e9272715838b5eada4cb13ce"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ab537d2f6e9272715838b5eada4cb13ce template"><td class="memItemLeft">std::ostream &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ab537d2f6e9272715838b5eada4cb13ce">operator&lt;&lt;</a> (std::ostream &amp;output, <a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;matrix)</td></tr>
<tr class="memdesc:ab537d2f6e9272715838b5eada4cb13ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a matrix to a stream.  <br /></td></tr>
<tr class="memitem:afda75107ba9ded61d0ae0c3d6a6281e3" id="r_afda75107ba9ded61d0ae0c3d6a6281e3"><td class="memTemplParams" colspan="2">template&lt;Field T&gt; </td></tr>
<tr class="memitem:afda75107ba9ded61d0ae0c3d6a6281e3 template"><td class="memItemLeft">constexpr std::size_t&#160;</td><td class="memItemRight"><a class="el" href="#afda75107ba9ded61d0ae0c3d6a6281e3">row_echelon_form</a> (std::in_place_t, <a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;matrix)</td></tr>
<tr class="memdesc:afda75107ba9ded61d0ae0c3d6a6281e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a matrix into a row echolon form in place.  <br /></td></tr>
<tr class="memitem:a76489395a9dfe76e436a325e779e804a" id="r_a76489395a9dfe76e436a325e779e804a"><td class="memTemplParams" colspan="2">template&lt;Field T&gt; </td></tr>
<tr class="memitem:a76489395a9dfe76e436a325e779e804a template"><td class="memItemLeft">constexpr <a class="el" href="structalgebra_1_1RowEchelonFormResult.html">RowEchelonFormResult</a>&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a76489395a9dfe76e436a325e779e804a">row_echelon_form</a> (<a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; matrix)</td></tr>
<tr class="memdesc:a76489395a9dfe76e436a325e779e804a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a matrix into a row echelon form.  <br /></td></tr>
<tr class="memitem:a53476fe37031aed47bb3b38d5e4b6dbc" id="r_a53476fe37031aed47bb3b38d5e4b6dbc"><td class="memTemplParams" colspan="2">template&lt;EuclideanDomain T&gt; </td></tr>
<tr class="memitem:a53476fe37031aed47bb3b38d5e4b6dbc template"><td class="memItemLeft">constexpr std::size_t&#160;</td><td class="memItemRight"><a class="el" href="#a53476fe37031aed47bb3b38d5e4b6dbc">smith_form</a> (std::in_place_t, <a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a53476fe37031aed47bb3b38d5e4b6dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a matrix into a Smith form in place.  <br /></td></tr>
<tr class="memitem:ad04bf6b87ead16604eb2ed6d6c5eabc4" id="r_ad04bf6b87ead16604eb2ed6d6c5eabc4"><td class="memTemplParams" colspan="2">template&lt;EuclideanDomain T&gt; </td></tr>
<tr class="memitem:ad04bf6b87ead16604eb2ed6d6c5eabc4 template"><td class="memItemLeft">constexpr <a class="el" href="structalgebra_1_1SmithFormResult.html">SmithFormResult</a>&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ad04bf6b87ead16604eb2ed6d6c5eabc4">smith_form</a> (<a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; matrix)</td></tr>
<tr class="memdesc:ad04bf6b87ead16604eb2ed6d6c5eabc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a matrix into a Smith form.  <br /></td></tr>
<tr class="memitem:a30e2cd1441a13b4316f9d045cd13dd28" id="r_a30e2cd1441a13b4316f9d045cd13dd28"><td class="memTemplParams" colspan="2">template&lt;int P&gt; </td></tr>
<tr class="memitem:a30e2cd1441a13b4316f9d045cd13dd28 template"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a30e2cd1441a13b4316f9d045cd13dd28">operator+</a> (<a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; lhs, <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a30e2cd1441a13b4316f9d045cd13dd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two integers mod P.  <br /></td></tr>
<tr class="memitem:abfee0c147692465af6f24e1bebf3253e" id="r_abfee0c147692465af6f24e1bebf3253e"><td class="memTemplParams" colspan="2">template&lt;int P&gt; </td></tr>
<tr class="memitem:abfee0c147692465af6f24e1bebf3253e template"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;&#160;</td><td class="memItemRight"><a class="el" href="#abfee0c147692465af6f24e1bebf3253e">operator-</a> (<a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; lhs, <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; rhs) noexcept</td></tr>
<tr class="memdesc:abfee0c147692465af6f24e1bebf3253e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two integers mod P.  <br /></td></tr>
<tr class="memitem:a305ca3e73277d0540d8fd0b941aab959" id="r_a305ca3e73277d0540d8fd0b941aab959"><td class="memTemplParams" colspan="2">template&lt;int P&gt; </td></tr>
<tr class="memitem:a305ca3e73277d0540d8fd0b941aab959 template"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a305ca3e73277d0540d8fd0b941aab959">operator*</a> (<a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; lhs, <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a305ca3e73277d0540d8fd0b941aab959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two integers mod P.  <br /></td></tr>
<tr class="memitem:ac31949c2c329ea54f19224c671cf935d" id="r_ac31949c2c329ea54f19224c671cf935d"><td class="memTemplParams" colspan="2">template&lt;int P&gt; </td></tr>
<tr class="memitem:ac31949c2c329ea54f19224c671cf935d template"><td class="memItemLeft">constexpr <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ac31949c2c329ea54f19224c671cf935d">operator/</a> (<a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; lhs, <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; rhs)</td></tr>
<tr class="memdesc:ac31949c2c329ea54f19224c671cf935d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides two integers mod P.  <br /></td></tr>
<tr class="memitem:a1b9022ec41069b03b873f9e47d3f846b" id="r_a1b9022ec41069b03b873f9e47d3f846b"><td class="memTemplParams" colspan="2">template&lt;int P&gt; </td></tr>
<tr class="memitem:a1b9022ec41069b03b873f9e47d3f846b template"><td class="memItemLeft">std::ostream &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a1b9022ec41069b03b873f9e47d3f846b">operator&lt;&lt;</a> (std::ostream &amp;output, <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; x)</td></tr>
<tr class="memdesc:a1b9022ec41069b03b873f9e47d3f846b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs an integer mod P to a stream.  <br /></td></tr>
<tr class="memitem:a74f5dd881b3d2aaa24108f1763c9ec72" id="r_a74f5dd881b3d2aaa24108f1763c9ec72"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#a74f5dd881b3d2aaa24108f1763c9ec72">is_prime</a> (int n) noexcept</td></tr>
<tr class="memdesc:a74f5dd881b3d2aaa24108f1763c9ec72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primality test.  <br /></td></tr>
<tr class="memitem:a27f271d9eb3292298bfd5f662309e248" id="r_a27f271d9eb3292298bfd5f662309e248"><td class="memItemLeft">constexpr <a class="el" href="structalgebra_1_1DivResult.html">DivResult</a>&lt; int &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a27f271d9eb3292298bfd5f662309e248">divide</a> (int a, int b)</td></tr>
<tr class="memdesc:a27f271d9eb3292298bfd5f662309e248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates quotient and remainder of two numbers.  <br /></td></tr>
<tr class="memitem:a35001d3da463f1cabac1ab9756ff8826" id="r_a35001d3da463f1cabac1ab9756ff8826"><td class="memItemLeft">constexpr int&#160;</td><td class="memItemRight"><a class="el" href="#a35001d3da463f1cabac1ab9756ff8826">modulo</a> (int a, int n)</td></tr>
<tr class="memdesc:a35001d3da463f1cabac1ab9756ff8826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the remainder of a by n.  <br /></td></tr>
<tr class="memitem:a5e24a9dee2493b919da91a1fd295e8a0" id="r_a5e24a9dee2493b919da91a1fd295e8a0"><td class="memItemLeft">constexpr <a class="el" href="structalgebra_1_1ExtendedGCDResult.html">ExtendedGCDResult</a>&#160;</td><td class="memItemRight"><a class="el" href="#a5e24a9dee2493b919da91a1fd295e8a0">extended_gcd</a> (int a, int b) noexcept</td></tr>
<tr class="memdesc:a5e24a9dee2493b919da91a1fd295e8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended Euclidean algorithm.  <br /></td></tr>
<tr class="memitem:a958499eaf6c9db8e9ee8576a9f77062b" id="r_a958499eaf6c9db8e9ee8576a9f77062b"><td class="memItemLeft">constexpr std::optional&lt; int &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a958499eaf6c9db8e9ee8576a9f77062b">inverse_mod</a> (int a, int n) noexcept</td></tr>
<tr class="memdesc:a958499eaf6c9db8e9ee8576a9f77062b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse modulo n.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af8da1be8b84633acd35c16535d5b41ec" id="r_af8da1be8b84633acd35c16535d5b41ec"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:af8da1be8b84633acd35c16535d5b41ec template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#af8da1be8b84633acd35c16535d5b41ec">is_commutative_v</a> = false</td></tr>
<tr class="memdesc:af8da1be8b84633acd35c16535d5b41ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template that can be used as a mark that class' main operation (addition or multiplication) is abelian.  <br /></td></tr>
<tr class="memitem:ac548cb6b55744bb48d4c003f49840cb6" id="r_ac548cb6b55744bb48d4c003f49840cb6"><td class="memItemLeft">constexpr <a class="el" href="structalgebra_1_1SkipCorrectnessCheckT.html">SkipCorrectnessCheckT</a>&#160;</td><td class="memItemRight"><a class="el" href="#ac548cb6b55744bb48d4c003f49840cb6">skip_correctness_check</a> {}</td></tr>
<tr class="memdesc:ac548cb6b55744bb48d4c003f49840cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper value of that <a class="el" href="structalgebra_1_1SkipCorrectnessCheckT.html" title="Type to mark an overload of a function, that doesn&#39;t perform optional correctness checks....">SkipCorrectnessCheckT</a>.  <br /></td></tr>
<tr class="memitem:a10eac0910d2c54aebc2b263729b3ee80" id="r_a10eac0910d2c54aebc2b263729b3ee80"><td class="memItemLeft">template&lt;&gt; </td></tr>
<tr class="memitem:a10eac0910d2c54aebc2b263729b3ee80 template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#a10eac0910d2c54aebc2b263729b3ee80">is_commutative_v&lt; Integer &gt;</a> = true</td></tr>
<tr class="memdesc:a10eac0910d2c54aebc2b263729b3ee80"><td class="mdescLeft">&#160;</td><td class="mdescRight">A marker that multiplying the integers is commutative.  <br /></td></tr>
<tr class="memitem:a2dac3b8ee50dc72992c1865808e707c3" id="r_a2dac3b8ee50dc72992c1865808e707c3"><td class="memTemplParams" colspan="2">template&lt;int P&gt; </td></tr>
<tr class="memitem:a2dac3b8ee50dc72992c1865808e707c3 template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#a2dac3b8ee50dc72992c1865808e707c3">is_commutative_v&lt; ZModP&lt; P &gt; &gt;</a> = true</td></tr>
<tr class="memdesc:a2dac3b8ee50dc72992c1865808e707c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A marker that multiplying integers mod P is commutative.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a1fa07827605fa9734220db771470424d" name="a1fa07827605fa9734220db771470424d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa07827605fa9734220db771470424d">&#9670;&#160;</a></span>Z2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1fa07827605fa9734220db771470424d">algebra::Z2</a> = <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt;2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="classalgebra_1_1ZModP_3_012_01_4.html" title="Template specialization for P == 2.">ZModP&lt;2&gt;</a>. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a9cc47983d14c3338d843c8fe61f6d7ae" name="a9cc47983d14c3338d843c8fe61f6d7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc47983d14c3338d843c8fe61f6d7ae">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1Integer.html">Integer</a> algebra::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns absolute value. </p>

</div>
</div>
<a id="ae5a6158e073a7727781c1aecc8ee5afb" name="ae5a6158e073a7727781c1aecc8ee5afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a6158e073a7727781c1aecc8ee5afb">&#9670;&#160;</a></span>ChainComplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::sized_range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">algebra::ChainComplex </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  ChainComplex&lt; typename std::ranges::range_value_t&lt; R &gt;::value_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for the <a class="el" href="classalgebra_1_1ChainComplex.html" title="Class representing a chain complex with coefficients T.">ChainComplex</a>. </p>

</div>
</div>
<a id="a1289f308542d523475a6610977fb0f09" name="a1289f308542d523475a6610977fb0f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1289f308542d523475a6610977fb0f09">&#9670;&#160;</a></span>ChainComplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::sized_range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">algebra::ChainComplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalgebra_1_1SkipCorrectnessCheckT.html">SkipCorrectnessCheckT</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  ChainComplex&lt; typename std::ranges::range_value_t&lt; R &gt;::value_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for the <a class="el" href="classalgebra_1_1ChainComplex.html" title="Class representing a chain complex with coefficients T.">ChainComplex</a>. </p>

</div>
</div>
<a id="a27f271d9eb3292298bfd5f662309e248" name="a27f271d9eb3292298bfd5f662309e248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f271d9eb3292298bfd5f662309e248">&#9670;&#160;</a></span>divide() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalgebra_1_1DivResult.html">DivResult</a>&lt; int &gt; algebra::divide </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates quotient and remainder of two numbers. </p>
<p>A function calculating numbers <span class="tt">quotient</span> and <span class="tt">remainder</span> satisfying <span class="tt">a == quotient * n + remainder</span> and 0 &lt;= remainder &lt; abs(n)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An integer </td></tr>
    <tr><td class="paramname">b</td><td>An integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A struct holding three numbers: <span class="tt">quotient</span>: the quotient <span class="tt">remainder</span>: the remainder </dd></dl>

</div>
</div>
<a id="a9d5f1816c22b13d7a8a6a9a93aaa0258" name="a9d5f1816c22b13d7a8a6a9a93aaa0258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5f1816c22b13d7a8a6a9a93aaa0258">&#9670;&#160;</a></span>divide() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalgebra_1_1DivResult.html">DivResult</a>&lt; <a class="el" href="classalgebra_1_1Integer.html">Integer</a> &gt; algebra::divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of integer division for Integers a and b. </p>
<p>Returns unique <span class="tt">q</span> and <span class="tt">r</span> satisfying</p><ol type="1">
<li><span class="tt">a == q * b + r</span></li>
<li><span class="tt">0 &lt;= r &lt; b.euclidean_function()</span> </li>
</ol>

</div>
</div>
<a id="a5e24a9dee2493b919da91a1fd295e8a0" name="a5e24a9dee2493b919da91a1fd295e8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e24a9dee2493b919da91a1fd295e8a0">&#9670;&#160;</a></span>extended_gcd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalgebra_1_1ExtendedGCDResult.html">ExtendedGCDResult</a> algebra::extended_gcd </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extended Euclidean algorithm. </p>
<p>Calculates the greatest common divisor <span class="tt">g</span> and integers <span class="tt">x</span>, <span class="tt">y</span> such that <span class="tt">a*x + b*y == g</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An integer </td></tr>
    <tr><td class="paramname">b</td><td>An integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A struct holding three numbers: <span class="tt">g</span>: the gcd <span class="tt">x</span>: first coefficient <span class="tt">y</span>: second coefficient </dd></dl>

</div>
</div>
<a id="a3b6f25acf54da436f6f0e4e65d317158" name="a3b6f25acf54da436f6f0e4e65d317158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6f25acf54da436f6f0e4e65d317158">&#9670;&#160;</a></span>homology() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Field T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalgebra_1_1Homology.html">Homology</a>&lt; T &gt; algebra::homology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1ChainComplex.html">ChainComplex</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>chain_complex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes homology of a chain complex with coefficients from a field. </p>

</div>
</div>
<a id="a3b6f25acf54da436f6f0e4e65d317158" name="a3b6f25acf54da436f6f0e4e65d317158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6f25acf54da436f6f0e4e65d317158">&#9670;&#160;</a></span>homology() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EuclideanDomain T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalgebra_1_1Homology.html">Homology</a>&lt; T &gt; algebra::homology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1ChainComplex.html">ChainComplex</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>chain_complex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes homology of a chain complex with coefficients from an euclidean domain. </p>

</div>
</div>
<a id="a958499eaf6c9db8e9ee8576a9f77062b" name="a958499eaf6c9db8e9ee8576a9f77062b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958499eaf6c9db8e9ee8576a9f77062b">&#9670;&#160;</a></span>inverse_mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int &gt; algebra::inverse_mod </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse modulo n. </p>
<p>Calculates inverse of <span class="tt">a</span> mod <span class="tt">n</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Inverted number </td></tr>
    <tr><td class="paramname">n</td><td>The modulus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <span class="tt">a</span> is invertible mod <span class="tt">n</span>, returns the inverse, <span class="tt">nullopt</span> otherwize </dd></dl>

</div>
</div>
<a id="a74f5dd881b3d2aaa24108f1763c9ec72" name="a74f5dd881b3d2aaa24108f1763c9ec72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f5dd881b3d2aaa24108f1763c9ec72">&#9670;&#160;</a></span>is_prime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool algebra::is_prime </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Primality test. </p>
<p>Tests, if a given number is prime, that is divisible only by 1 and by itself</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span>, if the number is prime, otherwise <span class="tt">false</span> </dd></dl>

</div>
</div>
<a id="abed0b66c149933f74c933def897afa3c" name="abed0b66c149933f74c933def897afa3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed0b66c149933f74c933def897afa3c">&#9670;&#160;</a></span>Matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::sized_range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">algebra::Matrix </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  Matrix&lt; std::ranges::range_value_t&lt; R &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce matrix value type from the submitted range. </p>

</div>
</div>
<a id="a35001d3da463f1cabac1ab9756ff8826" name="a35001d3da463f1cabac1ab9756ff8826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35001d3da463f1cabac1ab9756ff8826">&#9670;&#160;</a></span>modulo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int algebra::modulo </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the remainder of a by n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An integer </td></tr>
    <tr><td class="paramname">n</td><td>an integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The remainder </dd></dl>

</div>
</div>
<a id="a7557df3e0d51e921d301661b095a8ccf" name="a7557df3e0d51e921d301661b095a8ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7557df3e0d51e921d301661b095a8ccf">&#9670;&#160;</a></span>modulo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1Integer.html">Integer</a> algebra::modulo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the remainder of division of a by n. </p>
<p>Returns an integer r, 0 &lt;= r &lt; n satisfying <span class="tt">a == q * n + r</span> </p>

</div>
</div>
<a id="a442462c93fc9e0ebffcc6e517e9e3796" name="a442462c93fc9e0ebffcc6e517e9e3796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442462c93fc9e0ebffcc6e517e9e3796">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1Integer.html">Integer</a> algebra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies two integers. </p>

</div>
</div>
<a id="a730f43d3ab3095a9a724122b2af5926e" name="a730f43d3ab3095a9a724122b2af5926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730f43d3ab3095a9a724122b2af5926e">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Ring T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; algebra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies two matrices. </p>
<p>Multiplies two matrices using the usual matrix multiplication. </p>

</div>
</div>
<a id="a305ca3e73277d0540d8fd0b941aab959" name="a305ca3e73277d0540d8fd0b941aab959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305ca3e73277d0540d8fd0b941aab959">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; algebra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies two integers mod P. </p>

</div>
</div>
<a id="ade04e6b8cc549a66f70769f8c44104f8" name="ade04e6b8cc549a66f70769f8c44104f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade04e6b8cc549a66f70769f8c44104f8">&#9670;&#160;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1Integer.html">Integer</a> algebra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two integers. </p>

</div>
</div>
<a id="a195973a6e4664deb9f404a54d2c04d1b" name="a195973a6e4664deb9f404a54d2c04d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195973a6e4664deb9f404a54d2c04d1b">&#9670;&#160;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AdditiveGroup T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; algebra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two matrices. </p>

</div>
</div>
<a id="a30e2cd1441a13b4316f9d045cd13dd28" name="a30e2cd1441a13b4316f9d045cd13dd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e2cd1441a13b4316f9d045cd13dd28">&#9670;&#160;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; algebra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two integers mod P. </p>

</div>
</div>
<a id="acb08f898d9c1b3fd624ef42e41a605a1" name="acb08f898d9c1b3fd624ef42e41a605a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb08f898d9c1b3fd624ef42e41a605a1">&#9670;&#160;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1Integer.html">Integer</a> algebra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts two integers. </p>

</div>
</div>
<a id="a04836ac6e8513865e36e05ceaa77c356" name="a04836ac6e8513865e36e05ceaa77c356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04836ac6e8513865e36e05ceaa77c356">&#9670;&#160;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AdditiveGroup T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; algebra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts two matrices. </p>

</div>
</div>
<a id="abfee0c147692465af6f24e1bebf3253e" name="abfee0c147692465af6f24e1bebf3253e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfee0c147692465af6f24e1bebf3253e">&#9670;&#160;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; algebra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts two integers mod P. </p>

</div>
</div>
<a id="ac31949c2c329ea54f19224c671cf935d" name="ac31949c2c329ea54f19224c671cf935d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31949c2c329ea54f19224c671cf935d">&#9670;&#160;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; algebra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides two integers mod P. </p>

</div>
</div>
<a id="a33030836db242b656162529d27fc5ffd" name="a33030836db242b656162529d27fc5ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33030836db242b656162529d27fc5ffd">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; algebra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Integer.html">Integer</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs an integer to a stream. </p>

</div>
</div>
<a id="ab537d2f6e9272715838b5eada4cb13ce" name="ab537d2f6e9272715838b5eada4cb13ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab537d2f6e9272715838b5eada4cb13ce">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; algebra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a matrix to a stream. </p>

</div>
</div>
<a id="a1b9022ec41069b03b873f9e47d3f846b" name="a1b9022ec41069b03b873f9e47d3f846b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9022ec41069b03b873f9e47d3f846b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; algebra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs an integer mod P to a stream. </p>

</div>
</div>
<a id="a76489395a9dfe76e436a325e779e804a" name="a76489395a9dfe76e436a325e779e804a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76489395a9dfe76e436a325e779e804a">&#9670;&#160;</a></span>row_echelon_form() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Field T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalgebra_1_1RowEchelonFormResult.html">RowEchelonFormResult</a>&lt; T &gt; algebra::row_echelon_form </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a matrix into a row echelon form. </p>
<p>Transforms a matrix into a row echelon form and returns the number of non-zero rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td><a class="el" href="classalgebra_1_1Matrix.html" title="A Matrix class.">Matrix</a> to be transformed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A struct containing two fields<ol type="1">
<li>row_echelon_form The transformed matrix</li>
<li>non_empty_rows the number of non-zero rows </li>
</ol>
</dd></dl>

</div>
</div>
<a id="afda75107ba9ded61d0ae0c3d6a6281e3" name="afda75107ba9ded61d0ae0c3d6a6281e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda75107ba9ded61d0ae0c3d6a6281e3">&#9670;&#160;</a></span>row_echelon_form() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Field T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t algebra::row_echelon_form </td>
          <td>(</td>
          <td class="paramtype">std::in_place_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a matrix into a row echolon form in place. </p>
<p>Transforms a matrix into a row echelon form in place and returns the number of non-zero rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matrix</td><td><a class="el" href="classalgebra_1_1Matrix.html" title="A Matrix class.">Matrix</a> to be transformed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero rows </dd></dl>

</div>
</div>
<a id="ad04bf6b87ead16604eb2ed6d6c5eabc4" name="ad04bf6b87ead16604eb2ed6d6c5eabc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04bf6b87ead16604eb2ed6d6c5eabc4">&#9670;&#160;</a></span>smith_form() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EuclideanDomain T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalgebra_1_1SmithFormResult.html">SmithFormResult</a>&lt; T &gt; algebra::smith_form </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a matrix into a Smith form. </p>
<p>Transforms a matrix into a Smith form and returns the smaller of non-zero rows or columns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td><a class="el" href="classalgebra_1_1Matrix.html" title="A Matrix class.">Matrix</a> to be transformed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A struct containing two fields<ol type="1">
<li>smith_form The transformed matrix</li>
<li>non_empty The number of non-zero rows or columns </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a53476fe37031aed47bb3b38d5e4b6dbc" name="a53476fe37031aed47bb3b38d5e4b6dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53476fe37031aed47bb3b38d5e4b6dbc">&#9670;&#160;</a></span>smith_form() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EuclideanDomain T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t algebra::smith_form </td>
          <td>(</td>
          <td class="paramtype">std::in_place_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classalgebra_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a matrix into a Smith form in place. </p>
<p>Transforms a matrix into a Smith form in place and returns the smaller of non-zero rows or columns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matrix</td><td><a class="el" href="classalgebra_1_1Matrix.html" title="A Matrix class.">Matrix</a> to be transformed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero rows or columns </dd></dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="af8da1be8b84633acd35c16535d5b41ec" name="af8da1be8b84633acd35c16535d5b41ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8da1be8b84633acd35c16535d5b41ec">&#9670;&#160;</a></span>is_commutative_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool algebra::is_commutative_v = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template that can be used as a mark that class' main operation (addition or multiplication) is abelian. </p>

</div>
</div>
<a id="a10eac0910d2c54aebc2b263729b3ee80" name="a10eac0910d2c54aebc2b263729b3ee80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10eac0910d2c54aebc2b263729b3ee80">&#9670;&#160;</a></span>is_commutative_v&lt; Integer &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="#af8da1be8b84633acd35c16535d5b41ec">algebra::is_commutative_v</a>&lt; <a class="el" href="classalgebra_1_1Integer.html">Integer</a> &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A marker that multiplying the integers is commutative. </p>

</div>
</div>
<a id="a2dac3b8ee50dc72992c1865808e707c3" name="a2dac3b8ee50dc72992c1865808e707c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dac3b8ee50dc72992c1865808e707c3">&#9670;&#160;</a></span>is_commutative_v&lt; ZModP&lt; P &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="#af8da1be8b84633acd35c16535d5b41ec">algebra::is_commutative_v</a>&lt; <a class="el" href="classalgebra_1_1ZModP.html">ZModP</a>&lt; P &gt; &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A marker that multiplying integers mod P is commutative. </p>

</div>
</div>
<a id="ac548cb6b55744bb48d4c003f49840cb6" name="ac548cb6b55744bb48d4c003f49840cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac548cb6b55744bb48d4c003f49840cb6">&#9670;&#160;</a></span>skip_correctness_check</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalgebra_1_1SkipCorrectnessCheckT.html">SkipCorrectnessCheckT</a> algebra::skip_correctness_check {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper value of that <a class="el" href="structalgebra_1_1SkipCorrectnessCheckT.html" title="Type to mark an overload of a function, that doesn&#39;t perform optional correctness checks....">SkipCorrectnessCheckT</a>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacealgebra.html">algebra</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
